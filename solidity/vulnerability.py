
import re as r
'''


#все пробелы к одиночному пробелу
def del_space(text):
    program = ''
    for str_old in text.splitlines():
        #i = str_old.find('\S')
        match  = r.search(r'\S', str_old)
        i = match.start()
        print(match +' i='+str(i))
        #s_str = match.group()# str_old[i:]
        print(str_old)

        print(s_str)
        #str_old = str_old[0:i] + s_str.replace('  ', ' ')
        program += str_old +'\n'
    return program
'''



# удаленные комментарии
comment_dict = {}
my_comment_beg = '//SolChk '
in_str = "\nВ строке № "
num_report = 0

# "удаление" комментариев
def del_comment(text):
    i = 0
    while '//' in text:
        i_beg = text.find('//')
        i_end = text.find('\n',i_beg)
        d_comment = text[i_beg:i_end] #  вырезаем комментарий
        comment_dict.update({'##'+str(i)+'##':d_comment}) # сохраняем в списке
        text=text[:i_beg]+'##'+str(i)+'##'+text[i_end:] # замена комментария в тексте
        i+=1

    while '/*' in text:
        i_beg = text.find('/*')
        i_end = text.find('*/',i_beg) + 2
        d_comment = text[i_beg:i_end] #  вырезаем комментарий
        comment_dict.update({'##'+str(i)+'##':d_comment}) # сохраняем в списке
        text=text[:i_beg]+'##'+str(i)+'##'+text[i_end:] # замена комментария в тексте
        i+=1
    #print(text)
    return text

#восстанавливаем комментарии
def repair_comment(text):
    for key in comment_dict:
        text = text.replace(key, comment_dict[key]) # замена на сохраненный комментарий
    #print(text)
    return text

'''
# Комментарий вида //...
def comment1(str_new):
    s_old = ''
    s = ''
    if '//' in str_new:
        s_old = str_new[:str_new.find('//')]
        s = s_old
    return s_old, s


# Комментарий вида /*...*/
def comment2(check, str_new):
    s_old = ''
    s = ''
    if check == 0:
        if '/*' in str_new:
            s_old = str_new[:str_new.find('/*')]
            check = 1
            s = s_old
        else:
            s_old = str_new
            s = s_old
    elif '*/' in str_new:
        check = 0
    return check, s_old, s
'''

def exact_find(w, s):
    return (' ' + w + ' ') in (' ' + s + ' ')


#Проверки
#нахождениее версии solidity
def sol_version(text, report, version, i_ver):
    global  num_report
    num_report = 0
    program = ''
    i = 1
    check = 0
    ch_pr = 0
    for str_old in text.splitlines():
        # Проверка на уязвимость:
        if ch_pr == 0:
            if "pragma solidity" in str_old:
                str_old.rstrip(' ')
                j = str_old.find('^') + 1
                l_ver = str_old[j:-1].split('.')
                version.append(l_ver[0])
                version.append(l_ver[1])
                version.append(l_ver[2])
                num_report += 1
                report += str(num_report)+") Смарт-контракт написан на " + str(version[0]) + '.' + str(version[1]) + '.' + str(
                            version[2]) + " версии solidity." + '\n'
                i_ver = i
                ch_pr = 1
        program += str_old + '\n'  # Добавление новой строки в текст программы
        i += 1

    if ch_pr == 0:
        num_report += 1
        report +="\n" + str(num_report)+") Не указана версия компилятора!"

    return report, program, i_ver

def first_sym(strm):
    i = 0
    for s in strm:
        if s != ' ' and s!= '\t':
            return i
        i += 1
    return -1

# Уязвимости:
def overflow(text, report, version, i_ver):
    global  num_report
    program = ''
    i = 1
    ch = 0
    ch_over = 0  # = -1, если есть мат. действие, 0 - если их нет, 1 - подкл. библиотека

    for str_old in text.splitlines():

        # Проверка на уязвимость:
        m_list = ["+", "-", "*", "/", "%"]
        for math in m_list:
            if math in str_old:
                ch_over = -1
                program += my_comment_beg+'Если есть возможность переполения рекомендуем использовать функции из SafeMath\n'  # Добавление новой строки в текст программы
                ch = 1

        if "import" in str_old and "SafeMath" in str_old:
            ch_over = 1

        program += str_old + '\n'
        i += 1
    #if ch_over == -1:
    #    report += "В смарт-контракте производятся математические действия. Есть риск появления переполнения.\nСледует " \
    #              "использовать библиотеку SafeMath. См. Документацию" + '\n'
    if ch == 1:
        num_report += 1
        report += "\n" + str(num_report)+") В смарт-контракте производятся математические действия. Есть риск появления переполнения.\nСледует " \
                 "использовать библиотеку SafeMath. См. Документацию" + '\n'

    return report, program

#Проверка публичности функций
def def_visibility(text, report, version, i_ver):
    global  num_report
    program = ''
    i = 1
    ceh = 0

    for str_old in text.splitlines():
        # Проверка на уязвимость:
        # if i_ver != -1:
        if exact_find("function", str_old):
            ch = 0
            m_list = ["external", "public", "internal", "private"]
            for mistake in m_list:
                if exact_find(mistake, str_old):
                    ch += 1
                    break
            if ch == 0:
                program += my_comment_beg+'Рекомендуем явно указывать модификатор доступа\n'  # Добавление новой строки в текст программы
                ceh = 1
        program += str_old + '\n'  # Добавление новой строки в текст программы
        i += 1
    if ceh == 1 :
        num_report += 1
        report += "\n" + str(num_report)+") Не было найденно модификатора доступа метода. " \
                                    "По умолчанию, методы без модификаторов объявляются публичными public" + '\n'

    return report, program

#С
def self_destruct(text, report, version, i_ver):
    global  num_report
    program = ''
    i = 1
    ch = 0
    mistake = "selfdestruct"

    for str_old in text.splitlines():
        # Проверка на уязвимость:
        # if i_ver != -1:
        if not exact_find("function", str_old):
            if mistake in str_old:
                program += my_comment_beg+'Необходимо проверить использование selfdestruct. Потенциальная угроза\n'  # Добавление новой строки в текст программы
                ch = 1

        program += str_old + '\n'  # Добавление новой строки в текст программы
        i += 1
    if ch == 1:
        num_report += 1
        report += "\n" + str(num_report)+") Было найденно : " + mistake + ". Вы уверенны, что хотите его " \
                                                                    "использовать? " + '\n'

    return report, program


def delegatecall(text, report, version, i_ver):
    global  num_report
    program = ''
    i = 1
    ch = 0
    mistake = "delegatecall"

    for str_old in text.splitlines():
        # Проверка на уязвимость:
        # if i_ver != -1:
        if not exact_find("function", str_old):

            if mistake in str_old:
                program += my_comment_beg+'Потенциальная угроза. Проверьте необходимость использования  DELEGATECALL\n'  # Добавление новой строки в текст программы
                ch = 1

        program += str_old + '\n'  # Добавление новой строки в текст программы
        i += 1
    if ch == 1:
        num_report += 1
        report += "\n" + str(num_report)+") Было найденно : " + mistake + ". Вы уверенны, что хотите его " \
                                                                    "использовать? Вам следует " \
                                                                    "проверять надёжность вызываемого" \
                                                                    " смарт-контракта." + '\n'
    return report, program

# вызов call проблема reentrancy
def callreentrancy(text, report, version, i_ver):
    global  num_report
    program = ''
    i = 1
    ch = 0
    mistake = ".call"

    for str_old in text.splitlines():
        # Проверка на уязвимость:
        # if i_ver != -1:
        if not exact_find("function", str_old):

            if mistake in str_old:
                program += my_comment_beg+'Потенциальная угроза reentrancy. Проверьте необходимость использования call.\n'  # Добавление новой строки в текст программы
                program += my_comment_beg+'Рекомендуется исползовать transfer.\n'  # Добавление новой строки в текст программы
                ch = 1

        program += str_old + '\n'  # Добавление новой строки в текст программы
        i += 1
    if ch == 1:
        num_report += 1
        report += "\n" + str(num_report)+") Было найденно : " + mistake + ". Вы уверенны, что хотите его " \
                                                                    "использовать? Рекомендуется " \
                                                                    "исползовать transfer." + '\n'

    return report, program

#проверка расстоновки скобок
def braces(text, report, version, i_ver):
    global  num_report
    program = ''
    i = 1
    check = 0
    b_s = 0
    b_e = 0

    for str_old in text.splitlines():
        # Проверка на уязвимость:
        # if i_ver != -1:
        j = 0
        while str_old.find('{', j) != -1:
            b_s += 1
            j = str_old.find('{', j) + 1
        j = 0
        while str_old.find('}', j) != -1:
            b_e += 1
            j = str_old.find('}', j) + 1

        program += str_old + '\n'  # Добавление новой строки в текст программы
        i += 1

    if b_s != b_e:
        num_report += 1
        report += "\n" + str(num_report)+") Проверь расстановку фигурных скобок! " + "В тексте найдено '{' - " + str(
            b_s) + ", а '}' - " + str(b_e)
    return report, program

#не инициализированные переменные
def non_init_var(text, report, version, i_ver):
    global  num_report
    program = ''
    ch = 0
    m_list = ["int", "address", "mapping", "bool", "bytes", "string", "struct"]
    #excep_list = ["public","private","constant","[]","[ ]", "{", "uint", "int", "address", "mapping", "bool", "bytes", "string"]
    #for str_old in text.splitlines():
    # Проверка на уязвимость:
    for stype in m_list:
        i = 0
        #while stype in text:
        while text.find(stype,i) != -1:
            i = text.find(stype,i)
            tmp_text = text[:i]
            i_prev = tmp_text.rfind('\n')
            i_end = text.find('\n', i)
            strm = text[i_prev + 1:i_end]
            #убираем последний символ, что бы не попал в наименование переменной
            strm = strm.replace(";","")
            strm = r.sub('##[0-9]*##', '', strm)
            #проверим есть ли в данной строке присовение значения
            #если есть маппинг, то другие значения не проверяем
            if stype != "mapping" and strm.find("mapping") != -1:
                i += 1
                continue
            #отсекаем приведение типов
            if stype != "mapping" and (strm.find(stype+"(") != -1 or strm.find(stype+" (") != -1):
                i += 1
                continue

            if (strm.find('=>') != -1) or (strm.find('=') == -1 and strm.find('function ') == -1 and strm.find('modifier ') == -1):
            #if (strm.find('=') == -1 and strm.find('function ') == -1 and strm.find('modifier ') == -1):

                str_split = strm.split(' ')
                #берем последнее слово т.к. это и есть наименование переменной
                my_str = str_split[-1]
                #проверяем есть ли где то присовение
                if text.find(" " + my_str+"=", i_end) == -1 and text.find(" " + my_str+" =", i_end) == -1 and\
                        text.find("\t" + my_str+"=", i_end) == -1 and text.find("\t" + my_str+" =", i_end) == -1:
                    ch = 1
                    text = text[0:i_prev] + "\n"+my_comment_beg+"Переменная "+my_str+" объявлена, но не инициализированна\n" + text[i_prev+1:]
                    i += i_end - i_prev + len("\n"+my_comment_beg+"Переменная "+my_str+" объявлена, но не инициализированна\n") + 1
            else:
                i += 1

    if ch == 1:
        num_report += 1
        report += "\n" + str(num_report)+") В контракте существуют объявленные, но при этом не инициализированные переменные\n"
    program = text
    return report, program



#Проверка ошибки на необработку возвращаемого значения функций send, call
def def_notifcall(text, report, version, i_ver):
    global  num_report
    program = ''
    i = 1
    ch = 0
    for str_old in text.splitlines():
        # Проверка на уязвимость:
        # if i_ver != -1:
        m_list = ["call(", "callcode(", "send(","call (", "callcode (", "send (",]
        for mistake in m_list:
            if str_old.find(mistake) != -1:
                #print('in mist')
                if (str_old.find('if(') == -1 and str_old.find('if (') == -1 and str_old.find('require(') == -1 and str_old.find('require (') == -1):
                    #print('in mist not if')
                    #добавить лидирующие пробелы
                    program += my_comment_beg+ " Необходимо проверять возвращаемое значние вызываемых функций CALL, CALLCODE, DELEGATECALL, SEND\n"
                    k = first_sym(str_old)
                    str_old = (" "*k) + "if !(" + str_old.lstrip()+ "){\n"+ (" "*k) + "  revert('Error Укажите сообщение об ошибке')}"  # Добавление новой строки в текст программы
                    ch = 1
                    break
        program += str_old + '\n'  # Добавление новой строки в текст программы
        i += 1
    if ch == 1:
        num_report += 1
        report += "\n" + str(num_report)+") Необходимо проверять возвращаемое значние вызываемых функций call, callcode, delegatecall, send\n"\
                  "Внимание! Код был изменен, добавлена проверка результатов вызова функции. Скорректируйте сообщение об ошибке!\n"


    return report, program
